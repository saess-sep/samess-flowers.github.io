---
layout: post
title:  "Assembling and building"
date:   2021-02-03 5:55:55 -0500
categories: tech macos
tags: macos jamf strategy
---
I had a great conversation earlier today.  I had a (client/customer/coworker/user/person) ask why they were being prompted repeatedly to update Chrome on their Mac.  The literal answer is that I've got [Installomator](https://github.com/scriptingosx/Installomator) set up via Jamf Pro to run at every check-in (approximately 20 minutes) for any computer with a non-current version of Chrome.  Installomator has a helpful little AppleScript dialog that pops up if the program being installed is currently open that asks the user if they want to close it and install or to leave it open and abort the install.

The issue was that they didn't want it to keep prompting them.  They were in a meeting, sharing their screen, and it was annoying and disruptive.  Unfortunately, the two systems at work here couldn't get an acceptable compromise besides the "automated annoyance system".  Installomator has a few different options for what to do when the program being installed is currently open.  You can fail silently or automatically close the open program, those are the obvious ones.  The prompt option normally will create an AppleScript dialog with the options listed that will abort or kill the process if the user says to proceed.  I've added in a widget called the "sadness timer" (the earliest draft had it named after one of my C3UPs who made it necessary) which will cause the dialog to fail if it a response isn't chosen after a configurable time (30 minutes by default).  The system is fail-safe as I have it configured.

Because Installomator is fail-safe, I want to give that prompt as much of a chance as possible to be accepted.  Jamf Pro has a few intervals for running a policy: at check-in (which is user configurable but is constant across the Jamf Pro instance), every day, every week, once ever, or when enrolled.  I have the patching system running only for "critical" applications, so I want to make sure that they get updated.  My options with those constraints defined are 1 daily chance or 27 daily chances to accomplish my objective to get those programs updated.  If I could have something between the two (hourly would be great), then I'd pick it, but I don't.

### Assembling a system
I don't like excuses, but my current environment gives me piles of them to use.  Because I'm taking off the shelf scripts and products and just slotting them together, if an option doesn't exist within a script or within Jamf, I can throw up my hands and say, "sorry, I don't have the button to push that fixes this issue".  Whether anyone buys that is beyond my knowledge.  I'd guess if the engineers who I'm usually excusing to knew I was working off of shell scripts, I would start seeing pull requests on my repos to fix their problem.  I've made some changes here and there, but I mostly review and implement solutions rather than roll my own.

I think I need to defend myself just a bit before I proceed.  I'm not a script kiddy deploying random wizard strings from StackExchange.  I do line by line reviews of any scripts I implement.  I'm assembling validated, working components into a test environment, testing them, and then pushing them to production.

The assembled system has a lot of UX problems.  The interfaces are different for each thing I do.  They're usually similar, since most are built out of AppleScript dialogs, but I've also got one built using JamfHelper.  The C3UP from the beginning mentioned that *an* update system gave three prompts before it began counting down to a forced upgrade.  The [script](https://github.com/bp88/JSS-Scripts/blob/master/AppleSoftwareUpdate.sh) is actually even better than that, it can even detect when Do Not Disturb is turned on.  That script was from a different author who had different sensibilities.  It wouldn't be a perfect fit for everyone, but it would have been better in this instance than the Installomator behavior.  

### Building
There have been a few things I couldn't find pre-built.  I made a comically over-engineered script to fix some crackly audio that some people saw in Zoom.  That script is as close to my platonic ideal of what I want it to do as pretty much anything I've done.  It's pure thought-stuff converted into a script.  

If I had an infinite amount of time, I would build everything.  I mean **everything**.  I hate things that are designed for other people, because other people aren't me.  If I had a non-infinite but arbitrarily large amount of time (let's say 80 working hours a week), I would build the important stuff.  In my vaguely defined job role, I view my Mac administration as "very important".  I don't think I'd make my own MDM, but I'd make all my own script components.  I'd have a style manual and use consistent icons, consistent language, consistent behavior.


I don't have infinite time, and I don't have 80 hours a week.  So some assembly is going to be required.  With that said, I think I need to put a greater emphasis on building or at least tuning solutions.  Changing all the buttons in a script to say something consistent isn't close to difficult, especially for something relatively evergreen with few upstream changes (e.g., not Installomator).  I need to really consider the effects of adding a component to the assembly.  If it's worse than whatever the worst thing in the stack is, then I've made the UX worse.  If it's better than everything else the stack, then I need to synthesize those changes into the rest of the stack so I don't have an inconsistently good experience.

### Coda
To tag back from the introduction, the solution was to have two separate policies, one configured on check-in with silent failing, and one daily with the prompt.  For anyone reading this who is wondering why it's not doing that yet, it's because I thought of it while writing this.  I gotta test stuff first.